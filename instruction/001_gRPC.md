# gRPCについて

gRPCはRESTやGraphQLと同様に、通信プロトコルの一つ

1. 主な特徴
   - Protocol Buffersを使用した効率的なデータシリアライズ
   - HTTP/2ベースの通信による高速な双方向ストリーミング
   - 多言語対応（Go, Java, Python, Node.js, etc.）
   - 型安全なAPI定義

2. 基本的な仕組み
   - `.proto`ファイルでサービスとメッセージを定義
   - コード生成ツールで各言語用のコードを自動生成
   - クライアント/サーバー間で効率的な通信を実現

3. 通信パターン
   - Unary RPC: 一般的な1リクエスト1レスポンス
   - Server Streaming: サーバーから継続的にデータを送信
   - Client Streaming: クライアントから継続的にデータを送信
   - Bidirectional Streaming: 双方向でデータをストリーミング

4. RESTとの比較
   - gRPC: バイナリベースで高速、型安全、コード生成
   - REST: テキストベース(JSON)、シンプル、広く普及

5. ユースケース
   - マイクロサービス間通信
   - モバイルアプリとバックエンド間の通信
   - リアルタイムの双方向通信が必要なシステム

### 簡単にまとめると
- 型安全
- マイクロサービスに用いられがち(そういうデータは無し)

# webで用いるためには
実はwebフロントエンドからの通信は色々あってHTTP/2 通信に対応していないのでただgRPCでコードを生成してもブラウザからの通信できない。<br/>
よって、webでgRPCを扱うためには何かしらの方法で HTTP/1.1 に変換する必要がある。<br/>

### 知りうる限りの方法(おすすめ順)

1. connect (本リポで採用)
    - 他と比べて何も考えなくて良い
    - api gatewayにもできる
    - RESTにもできる
    - 但しpostしか定義できない

2. grpc-gateway
    - プロキシサーバーを作る
    - プロキシサーバー宛にREST通信
    - backendサーバー宛にgRPC の両方が可能
    - プロキシサーバーを建てないといけないので api gatewaにはできない? っぽい

3. envoy (試してもいない)
    - grpc-gatewayと同じっぽい

4. nextjsのAPIルート
    - APIルートはサーバーサイドになるため、HTTP/2通信ができる
    - やってることはプロキシサーバーを建てるのと同じだが、物理的なプロキシサーバーが不要
    - client -> APIルート間の処理は書かないといけない
    - connectで良い


# gRPCの基本的な使い方
1. .protoファイルを作成
2. コマンド(buf)でリクエスト & 受信用コード生成
3. バックエンドは受信用コードをインターフェースにしてビジネスロジックなどを書く
4. フロントはその逆
5. 以上
